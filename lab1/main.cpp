#include <iostream>

#include "myRect.h"
#include "myString.h"
#include "Bochka.h"

#define stop __asm nop

void main()
{
	using namespace std;
	/*
		//Задание 1.Объявление класса. Создание экземпляра класса.
		//Вызов методов класса.
		//Откройте закладку Class View - (здесь Вы увидите имена методов и
		//данных - классов Rect и MyString)
		//Обратите внимание на пиктограммы слева от имен членов класса - они
		//обозначают спецификатор доступа к каждому члену класса.

		//Какой конструктор вызывается при создании экземпляра класса?
		{
			//Rect rect; // вызывается конструктор по-умолчанию
			stop
		}

		//1a. Объявите и определите конструктор с параметрами для
		//инициализации переменных класса. Создайте экземляры класса Rect
		//с помощью конструктора с параметрами. Если компилятор выдает
		//ошибку в предыдущем фрагменте, подумайте - чего ему не
		//хватает? Добейтесь отсутствия ошибок.
		//Выполняя задание с самого начала по шагам, определите:
		//в какой момент происходит вызов конструктора(какого?)?


		stop
		//1б. При конструировании объекта посредством конструктора без параметров
		//предусмотрите инициализацию переменных класса, например, нулем



		//1в. Подумайте, как следует поступать в случае, когда пользователь задал
		//координаты следующим образом:

		//Rect rrr(4,3,2,1);

		stop
		//1г. Объявите, определите и вызовите метод класса InflateRect(),
		//который увеличивает размеры прямоугольника на заданные приращения
		//(раздвигая стороны от центра - каждую сторону на свое значение).
		//Подсказка: объявить и определить методы можно не только "вручную",
		//но и с помощью Wizard-a Class View. Для этого: откройте закладку
		//ClassView окна проекта, сделайте активным класс Rect и нажмите
		//правую кнопку мыши - в появившемся контекстном меню выберите
		//Add/Add Member Function... С помощью появившейся диалоговой панели
		//"дайте указания" Wizard-у как объявить и определить метод.




		stop


		//Задание 2.Перегрузка конструкторов и методов класса.
		//Конструктор копирования.

		//2а.Объявите и определите конструктор копирования в классе Rect.
		//Выполняя задание по шагам, определите, какой
		//конструктор вызывается при создании r1,r2,r3 и r4?
		//Чему равны переменные созданных объектов?
			Rect r1; // конструктор по умолчанию
			Rect r2(1,2,3,4); // конструктор с параметрами
			Rect r3 = r1; // конструктор копирования
			Rect r4(r2); // конструктор копирования
			stop


	  //2б. Объявите и определите в классе Rect метод InflateRect(),
		//который принимает два аргумента, по умолчанию равных 1, и
		//раздвигает стороны прямоугольника на на заданные приращения.
		//Для каких объектов вызывается функция InflateRect()?
			r1.InflateRect(1,1); // для объекта r1
			r2.InflateRect(2,2); // для объекта r2
		//Какая из функций InflateRect() вызывается в каждом из трех случаев?
			r3.InflateRect(2,2,2,2); // InflateRect() для 4х параметров
			r3.InflateRect(3,3); // InflateRect() для 2х параметров, а в нем для 4х
			r3.InflateRect(5); // InflateRect(5, 1) для 2х параметров, а в нем для 4х
			r3.InflateRect(); // InflateRect(1, 1) для 2х параметров, а в нем для 4х
		stop



		//Задание 3.Спецификаторы доступа. Инкапсуляция.
		{
		Rect r;
		//Раскомментируйте следующую строку. Объясните ошибку
		//компилятора

		//int tmp = r.m_left; // поле класса Rect m_left объявлено как private и недоступно вне класса

		//Введите в класс Rect метод void SetAll(...),
		//который присваивают переменным класса передаваемые
		//значения. Вызовите созданный метод, проверьте корректность.

		r3.SetAll(5, 4, 3, 2);
		r3.SetAll(2, 3, 4, 5);

		//Введите в класс Rect парный метод GetAll(...),
		//который "достает" значения private-переменных класса.
		//Вызовите созданный метод, проверьте корректность.
		int left, right, top, bottom;
		r3.GetAll(left, right, top, bottom);

		stop
		}


		//Задание 4.Передача экземпляра класса в качестве параметра
		//функции. Возвращение объекта класса по значению. Поставив
		//остановы в конструкторе копирования или выполняя фрагмент
		//по шагам, определите: в какой момент происходит обращение
		//к конструктору копирования.
		//Создайте глобальную функцию
		// Rect BoundingRect(Rect, Rect);
		//которая принимает два объекта класса Rect по значению и
		//возвращает объект класса Rect, который является прямоугольником,
		//в который вписаны заданные прямоугольники. Как происходит
		//передача параметров и возвращение объекта класса?

		//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
		//может оказаться "ненормализованным", то есть m_left>m_right или/и
		//m_top>m_bottom

		{

			Rect r1(1,2,3,4), r2(5,6,7,8), r3, r4;
			r3 = BoundingRect(r1, r2); // вызывается конструктор копирования сначала для 2го параметра (r2), потом для первого (r1)
										// для возврата объекта вызывается конструктор с параметрами
			stop

				//Задание 4а. Передача объектов по ссылке.
				//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
				//задачу, принимая параметры по ссылке
				//Вызываются ли конструкторы при передаче параметров?

				r3 = BoundingRect2(r1, r2); // конструкторы копирования не вызываются
				r4.BoundingRect(r1, r2);
		stop
		}


	*/
	/*
		//Задание 5. Указатель на класс. Объявите и определите
		//явный деструктор класса. Поставьте остановы в
		//конструкторе (конструкторах) и деструкторе. Определите: когда для
		//каждого из объектов вызывается конструктор, а когда - деструктор?
		{
			cout << "Task 5" << endl;
			Rect r1; // вызывается конструктор по умолчанию
			Rect*	pR = new Rect(1,2,1,2);	// вызывается конструктор с параметрами
			{
				Rect r2(r1); // вызывается конструктор копирования
				Rect arRect[2]; // 2 раза вызывается конструктор по умолчанию
				for(int i=0; i<3; i++)
				{
					static Rect r3 (i,i,i,i) ; // при первом входе в цикл вызывается конструктор с параметрами (при последующих не вызывается и значения не меняются)
					Rect r4(*pR); // вызывается конструктор копирования в каждой итерации цикла
					Rect r5(i,i,i,i); // вызывается конструктор с параметрами в каждой итерации цикла
				} // вызывается деструктор 2 раза (для r4 и r5)
			} // вызывается деструктор для r2 и arRect
			delete pR;	// вызывается деструктор
			//stop
		} // вызывается деструктор для r1
		*/
		//
		////Задание 6.Конструктор + деструктор = функциональное
		//// замыкание. Класс MyString
		//// Посредством конструктора (конструкторов) и деструктора обеспечьте
		////корректные инициализацию и деактивацию объекта
		////C помощью остановов определите когда происходит
		////захват и освобождение памяти для строки-члена класса
		//{
		//	MyString	str("It's my string!");

		//	//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//	//С помощью cout и метода GetString() распечатайте строку объекта str
		//	//Замечание: подумайте, как следует корректно реализовать метод GetString().

		//	const char* pntrStr = str.GetString();
		//	//*(str.GetString())='W';
		//	cout << pntrStr;
		//}
		////stop


		////6a. Раскомментируйте следующий фрагмент. Подумайте - какие
		////неприятности Вас ожидают. Попробуйте исправить положение (как?)
		//	{
		//		MyString str1("The first string!");
		//		MyString str2 = str1; // необходимо создать конструктор копирования

		//	}
		//	//stop

		////6б. Реализуйте метод SetNewString, который будет заменять строку
		//// на новую
		//	{
		//		MyString str1("The first string!");
		//		str1.SetNewString("The NEW string!");
		//		cout << endl;
		//	}


		////6г. Создайте глобальную функцию, которая будет принимать любое
		////количество указателей на строки, а возвращать объект MyString,
		////в котором строка будет конкатенацией параметров
		//	{
		//		char * arrCh[] = { "ABC", "de", "g" };
		//		MyString str = ConcatStrings(arrCh[0], arrCh[1], arrCh[2], 0);
		//	}


		////Задание 7.Массив объектов класса.
		//{
		////Объявите и проинициализируйте массив ar из объектов
		//// типа MyString. Например:
		////Как задать размерность? N=3
		////MyString arstr[N] = {...
		//		const size_t N = 3;
		//		MyString arstr[N] = { MyString("ABC"), MyString("de"), MyString("f") };

		////Проверка - печать строк-членов класса
		//		for (size_t i = 0; i < sizeof(arstr) / sizeof(MyString); i++)
		//		{
		//			cout << arstr[i].GetString();
		//		}

		////Увеличьте размер массива, не изменяя список инициализаторов:
		////N=5???
		//		const size_t N1 = 5;
		//		// вызывается 3 раза конструктор с параметрами, последние 2 объекта создаются с конструктором по умолчанию
		//		MyString arstr1[N1] = { MyString("ABC"), MyString("de"), MyString("f") };

		////Объявите и проинициализируйте массив объектов	типа Rect.
		//		Rect arRect[N] = { Rect(1, 2, 1, 2), Rect() }; // для 3его объекта будет неявно вызван конструтор по умолчанию
		//}
		////stop


		////Задание 8.Массив указателей на объекты класса.
		//{
		////Объявите и проинициализируйте массив arPtr из трех
		////указателей на объекты типа MyString.
		//	MyString * arPtr[5] = {new MyString("abc"), new MyString("de"), new MyString("f")};

		////Печать строк-членов класса

		//	for (size_t i = 0; i < sizeof(arPtr) / sizeof(MyString); i++)
		//	{
		//		if(arPtr[i]) cout << arPtr[i]->GetString() << endl;
		//	}

		//	for (size_t i = 0; i < sizeof(arPtr) / sizeof(MyString); i++)
		//	{
		//		delete arPtr[i];
		//	}
		//}
		////stop
		//

		//Задание 9.  Решите с помощью классов следующую задачу:
		//даны две бочки известного объема. В одной бочке в начальный момент
		//времени содержится спирт (96%), в другой – вода.
		//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
		//в другую следующим способом: на каждой итерации
		//зачерпнули из первой бочки -> вылили во вторую
		//зачерпнули из второй бочки -> вылили в первую.
		//Требуется определить номер итерации, на которой концентрация спирта в
		//первой бочке станет меньше 50%.
	{
		Bochka spirt(100, 0.96);
		Bochka water(100, 0);

		int counter = 0;

		while (spirt.SpirtVol() > 0.5)
		{
			spirt.Pereliv(water, 1);
			water.Pereliv(spirt, 1);

			counter++;
		}

		cout << "Iterations: " << counter << endl;
		cout << spirt.SpirtVol() << endl;
		cout << water.SpirtVol() << endl;

	}
	
}//end_main