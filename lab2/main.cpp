// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.

#include <tchar.h>
#include <iostream>
#include "Rect.h"
#include "Circle.h"
#include "MyByte.h"

using namespace std;

//#define	  stop __asm nop

int _tmain(int argc, _TCHAR* argv[])
{
	//Задание 1.Простое наследование.Аргументы конструктора,
	// передаваемые в базовый класс.

	//Создайте иерархию классов:
	//базовый класс Shape (который описывает любую фигуру)
	//и два производных класса Rect и Circle.
	//Подумайте: какие данные и методы нужно ввести в базовый
	//и производные классы (например, любую фигуру можно сделать
	//цветной => в базовом классе можно ввести переменную, которая
	//будет определять цвет фигуры.
	//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);	

	
	//В конструкторах производных классов предусмотрите передачу
	//параметра-цвета конструктору базового класса.
	//При создании и уничтожении объекта производного типа определите
	//последовательность вызовов конструкторов и деструкторов базового
	//и производного классов

	// При создании объекта проиводного типа сначала вызывается конструктор базового типа,
	// а затем производного. Деструкторы вызываются в обратном порядке.
	/*
	{
		Circle c1(1, 2, 3);
	}
	*/	

//////////////////////////////////////////////////////////////////////

//Задание 2.Виртуальные функции.
//2а) Модифицируйте классы Shape,Rect и Circle:
//добавьте в каждый класс public метод void WhereAmI().
//Реализация каждой функции должна выводить сообщение 
//следующего вида "Now I am in class Shape(Rect или Circle)".
//Выполните приведенный фрагмент, объясните результат.

/*
{
	Shape s(RED);
	Rect r(1, 2, 3, 4);
	Circle c(1, 2, 3);


	//Метод какого класса вызывается в следующих строчках???
	s.WhereAmI();	//	Shape
	r.WhereAmI();	//	Rect
	c.WhereAmI();	//	Circle

	Shape* pShape = &s;
	Shape* pRect = &r;
	Shape* pCircle = &c;
	pShape->WhereAmI();	//	Shape
	pRect->WhereAmI();	//	Shape
	pCircle->WhereAmI(); //	Shape

						 //Заполните ... согласно комментариям
	Shape& rShape = s; //псевдоним s
	Shape& rRect = r; //псевдоним r
	Shape& rCircle = c; //псевдоним c
	rShape.WhereAmI();	//вызов посредством rShape	Вызывается метод класса Shape
	rRect.WhereAmI();	//вызов посредством	rRect	Вызывается метод класса Shape
	rCircle.WhereAmI(); //вызов посредством rCircle	Вызывается метод класса Shape
}


//2б) Сделайте метод WhereAmI() виртуальным.
//Снова выполните приведенный фрагмент, объясните разницу.

{
	Shape s(RED);
	Rect r(1, 2, 3, 4);
	Circle c(1, 2, 3);


	//Метод какого класса вызывается в следующих строчках???
	s.WhereAmI();	//	Shape
	r.WhereAmI();	//	Rect
	c.WhereAmI();	//	Circle

	Shape* pShape = &s;
	Shape* pRect = &r;
	Shape* pCircle = &c;
	pShape->WhereAmI();	//	Shape
	pRect->WhereAmI();	//	Rect
	pCircle->WhereAmI(); //	Circle

	//Заполните ... согласно комментариям
	Shape& rShape = s; //псевдоним s
	Shape& rRect = r; //псевдоним r
	Shape& rCircle = c; //псевдоним c
	rShape.WhereAmI();	//вызов посредством rShape	Вызывается метод класса Shape
	rRect.WhereAmI();	//вызов посредством	rRect	Вызывается метод класса Rect
	rCircle.WhereAmI(); //вызов посредством rCircle	Вызывается метод класса Circle
}
*/

//////////////////////////////////////////////////////////////////////

	//Задание 3.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.

	/*
	{
		Rect r(1, 2, 3, 4);
		Shape* ar[] = {
			new Shape(r),
			new Rect(r),
			new Circle(r),
			new Circle() };

			for (size_t i = 0; i < sizeof(ar) / sizeof(Shape*); i++)
			{
			delete ar[i]; // вызываются деструкторы Shape
			}
	} // вызываются деструкторы Rect и Shape для r
	*/
	

	// b) Добавьте в объявление деструкторов ключевое слово virtual 
	//Выполните фрагмент.Объясните разницу.


	//Подумайте: какие конструкторы вызываются в следующей строке?
		//Если в разработанных классов каких-то конструкторов
		//не хватает - реализуйте
		//Если Вы считаете, что в приведенном фрагменте чего-то
		//не хватает - добавьте
/*
{
Rect r(1, 2, 3, 4);
Shape* ar[] = {
	new Shape(r),
	new Rect(r),
	new Circle(r),
	new Circle() };

//Вызовите для каждого элемента массива метод WhereAmI()
for (size_t i = 0; i < sizeof(ar) / sizeof(Shape*); i++)
{
	ar[i]->WhereAmI(); // вызывается метод класса, которому принадлежит объект (Shape, Rect, Circle, Circle)
}

for (size_t i = 0; i < sizeof(ar) / sizeof(Shape*); i++)
{
	delete ar[i]; // для объектов дочерних классов вызывается сначала деструктор своего, а затем базового класса
}
} // вызываются деструкторы Rect и Shape для r		
*/


	//Задание 4*. В чем заключается отличие 1) и 2)

	{
		Shape* pShapes = new Rect[10];//1)
		Rect* pRects = new Rect[10];//2)

		//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
		//в чем заключается проблема???
		Rect * pR = static_cast<Rect *>(pShapes);
		for (size_t i = 0; i < 10; i++)
		{
			pR[i].WhereAmI(); // вызовется только для первого элемента, а дальше упадет с ошибкой
			//static_cast<Rect *>(pShapes)[i].WhereAmI();
		}
		for (size_t i = 0; i < 10; i++)
		{
			pRects[i].WhereAmI(); // вызовется нормально для всех членов массива
		}

		//Освободите динамически захваченную память

		delete[] pShapes;
		delete[] pRects;
	}
	

//////////////////////////////////////////////////////////////////////

	//Задание 5.Виртуальные функции и оператор разрешения области видимости. 
    
	{
		Rect r(1, 2, 3, 4);
		Shape* p = &r;	
		p->WhereAmI(); // вызывается метод класса Rect	
		
		//4a Оператор разрешения области видимости.
		//Посредством объекта r и указателя p вызовите виртуальную функцию
		//WhereAmI()класса Shape
		
		r.Shape::WhereAmI();
		p->Shape::WhereAmI();
		
	}
	

//////////////////////////////////////////////////////////////////////

	//Задание 6.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	
	{
		Rect r(1, 2, 3, 4);
		Shape* p = &r;
		p->Inflate(5);
		Circle c(1, 2, 3);
		p = &c;
		p->Inflate(5);
	}
	

//////////////////////////////////////////////////////////////////////

	//Задание 7.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	MyByte byte(0x1f);
	byte.ShowBin();
	byte.ShowOct();
	byte.ShowDec();
	byte.ShowHex();

	byte.EditBin(5, 0);

	byte.ShowBin();
	byte.ShowOct();
	byte.ShowDec();
	byte.ShowHex();

	byte.EditHex(0, 15);
	byte.EditHex(1, 0);
	byte.ShowHexPos(0);

	byte.ShowBin();
	byte.ShowOct();
	byte.ShowDec();
	byte.ShowHex();		
	
	return 0;
}//endmain

